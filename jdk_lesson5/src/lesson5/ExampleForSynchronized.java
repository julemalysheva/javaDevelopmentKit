package lesson5;

/**
 * что
 * происходит когда два и более потока начинают конкурировать за ресурсы (т.е.
 * пытаются в параллели получить доступ к одному и тому же объекту или ресурсу).
 * При работе потоки нередко обращаются к каким-то общим ресурсам, которые
 * определены вне потока, например, обращение к какому-то файлу или подключение
 * к базе данных. Если одновременно несколько потоков обратятся к такому ресурсу
 * на запись (т.е. с целью изменения состояния), то результаты выполнения программы
 * будут сложно предсказуемыми или это может привести к ошибке выполнения.
 *
 * Попробуйте несколько раз запустить данный код, чтобы убедиться, что
 * последовательность запуска потоков отличается каждый раз
 */

public class ExampleForSynchronized {
    static Integer object = Integer.valueOf(0);

    public static void main(String[] args) {
        Runnable task = () -> {
            object = object + 1;
            System.out.println(Thread.currentThread().getName());
        };
        Thread thread = new Thread(task);
        thread.start();
        System.out.println(Thread.currentThread().getName());
        object = object + 1;
        System.out.println(object.intValue());
    }
}

/**
 * Самым простым способом синхронизировать потоки (т.е. определить их поведение
 * при работе с общим объектом) — это концепция «монитора» и ключевое слово
 * synchronized (обратите внимание, что у любого наследника класса Object есть свой
 * собственный «монитор» — именно поэтому нельзя синхронизировать примитивные
 * типы). Монитор характеризуется следующей информацией:
 * ● состоянии (locked) — признак, что монитор захвачен потоком;
 * ● владелец (owner) — каким потоком захвачен монитор в текущий момент;
 * ● перечень потоков, которые не смогли захватить монитор (blocked set), так как
 * монитор захвачен другим потоком;
 * ● перечень потоков у которых был вызван метод wait (wait set).
 * Для синхронизации потоков используется ключевое слово synchronized (обратите
 * внимание, что всегда синхронизируется именно объект — только у него есть
 * монитор). Давайте посмотрим, что происходит, когда поток пытается захватить
 * монитор объекта:
 * ● Поток попадает в синхронизированный блок кода (synchronized блок);
 * ● В синхронизированном объекте проверяются переменные locked и owner
 * монитора.
 * ● Если эти поля false и null, соответственно, они заполняются. Если переменная
 * owner не равна потоку, который хочет захватить монитор, то поток
 * блокируется и попадает в blocked set монитора
 * ● Поток начал выполнять код (соответствует открывающей фигурной скобке
 * synchronized блока)
 * ● Поток завершил выполнение кода (соответствует закрывающейся фигурной
 * скобке блока синхронизации)
 * ● Переменные locked и owner монитора очищаются.
 *
 * Теперь давайте посмотрим как мы можем синхронизировать соответствующий
 * объект.
 * Во-первых, можно синхронизировать методы самого класса. В этому случае
 * объектом синхронизации является сам объект — this:
 *
 * Во вторых, можно синхронизировать другой объект в целевом классе:
 *
 * В третьих, в случае синхронизации статических методов мы используем монитор
 * самого класса:
 */

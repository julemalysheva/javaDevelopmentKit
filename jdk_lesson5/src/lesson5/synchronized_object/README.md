### Пример использования методов wait(), notify() и notifyAll() в многопоточной программе:

В этом примере, класс MessageStorage представляет общее хранилище сообщений, в котором производитель (Producer) может установить сообщение, а потребитель (Consumer) может получить сообщение. Методы setMessage() и getMessage() синхронизированы с помощью ключевого слова synchronized, чтобы обеспечить правильное взаимодействие между потоками.

В методе setMessage(), если message уже установлен, поток будет ждать с помощью метода wait(). Когда сообщение устанавливается, вызывается метод notifyAll(), чтобы разбудить ожидающие потоки.

В методе getMessage(), если message еще не установлен, поток будет ждать с помощью метода wait(). Когда сообщение получено, оно возвращается, а метод notifyAll() вызывается, чтобы разбудить ожидающие потоки.

Классы Producer и Consumer реализуют интерфейс Runnable и представляют производителя и потребителя соответственно. В классе Main создаются и запускаются потоки для производителя и потребителя.

Это простой пример, но он демонстрирует базовое использование методов wait(), notify() и notifyAll() для организации взаимодействия между множеством потоков.

***

В процессе работы приложения,
довольно часто могут возникать ситуации, что поток ожидает события,
необходимого для продолжения выполения своей работу (например ответ от web
сервера на http запрос) — такой поток блокирует работу всего приложения — в этом
случае логичным решением является уступить ресурс, другому потоку, который в
текущий момент времени может выполнять свои задачи. У класса Object (а значит у
всех не примитивных типов), есть следующие методы, которые позволяют
управлять переключением потока:

● wait() — После вызова этого метода поток попадает в wait set монитора, сам
же монитор освобождается (переменные locked и owner в мониторе
очищаются)

● notify() — Для того чтобы потоки, которые находятся в wait set, продолжили
свое выполнение, другой поток должен захватить монитор и вызвать методы
notify(). После вызова метода notify() из wait set выбирается произвольный
поток и переводится в blocked set. После того как этот поток выйдет из
synchronized блока, нотифицированные потоки будут по одному захватывать
монитор и продолжать выполнение

● notifyAll() — аналогично notify(), но все потоки из wait set переводятся в
blocked set

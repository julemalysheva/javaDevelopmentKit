package lesson5;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * В этом примере используется пул потоков, созданный с помощью метода newFixedThreadPool() из класса Executors.
 * Пул потоков имеет фиксированное число потоков равное 4.
 * Мы подготовили задачу, представленную интерфейсом Runnable, которая будет выполняться каждым потоком из пула.
 * Задача заключается в выводе информации о текущем потоке выполнения.
 * Затем мы запускаем выполнение задач, используя метод execute() из ExecutorService.
 * Мы запланировали выполнение 10 таких задач.
 * В конце мы вызываем метод shutdown() на ExecutorService, чтобы завершить работу пула потоков.
 * Обратите внимание, что в реальной ситуации за задачами может следовать блокировка или ожидание результата выполнения.
 * Этот код предоставляет простой пример использования пула потоков и демонстрирует его основные возможности.
 */

public class ThreadPoolExample {
    private static final int NUM_TASKS = 10;

    public static void main(String[] args) {
        // Создаем пул потоков с фиксированным числом потоков (4)
        ExecutorService executorService = Executors.newFixedThreadPool(4);

        // Подготавливаем задачи для выполнения
        Runnable task = () -> {
            String thredName = Thread.currentThread().getName();
            System.out.println("Задача выполняется в потоке: " + thredName);
            //Выполнение задачи
        };

        //Планируем выполнение задачи
        for (int i = 0; i < NUM_TASKS; i++) {
            executorService.execute(task);
        }

        //Завершаем работу пула потоков
        executorService.shutdown();
    }
}

/**
 * Пул потоков
 * Процесс создания новых потоков и освобождение ресурсов являются
 * дорогостоящей операцией. Мы можем изначально определить необходимое
 * количество потоков, создать их и использовать для решения задач — в java для
 * этого используются пулы потоков и очереди задач, из которых выбираются задачи
 * для потоков. Пул потоков — это по сути контейнер, в котором находятся потоки, и
 * после выполнения одной из задач они самостоятельно переходить к следующей.
 * Вы можете использовать такой контейнер для контроля создания и управления
 * потоками — это экономит ресурсы связанные с процессом создания новых потоков.
 * Рассмотрим классы и интерфейсы, которые отвечают создание и управление пулом
 * потоков (Executor Framework in Java):
 * Интерфейс Executor. Объекты, которые реализуют интерфейс Executor, могут
 * выполнять runnable-задачу (Интерфейс имеет один метод void
 * execute(Runnable command)).
 * ExecutorService. Интерфейс ExecutorService наследуется от интерфейса
 * Executor и предоставляет возможности для выполнения заданий Callable.
 * Класс Executors. Утилитарный класс Executors создает классы, которые
 * реализуют интерфейсы Executor и ExecutorService.
 * Теперь давайте посмотрим на основные реализации интерфейсов Executor и
 * ExecutorServcie:
 * ● ThreadPoolExecutor — пул потоков содержит фиксированное количество
 * потоков - количество потоков определяется через конструктор.
 * ● Executors.newCachedThreadPool() - возвращает пул потоков, если количество
 * потоков в пуле не достаточно, то в нем будет создан новый поток.
 * ● Executors.newSingleThreadExecutor() — пул потоков, который гарантирует, что
 * в нем может быть только один поток.
 * ● ScheduledThreadPoolExecutor — пул потоков используется для запуска
 * периодических задач или задач, которые должны запуститься только раз по
 * истечении некоторого промежутка времени.
 */
